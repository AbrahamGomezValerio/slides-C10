---
title: Cap8
layout: post
permalink: /Cap8/
---
				<section>
					<p>Nombre: Abraham Alejandro Gómez Valerio <br>
						Tema: Detección de errores y corrección <br>
						Método: RevealJS y Slides
					</p>
				</section>
				<section>
					<b>Introducción</b>
					<br>
					<p>Las redes deben ser capaces de transferir datos de un dispositivo a otro con una buena precisión. Lma mayoría de aplicaciones deben garantizar que los datos recibidos sean iguales a los transmitidos
						Cada vez que se transmiten datos pueden existir errores o que se corrompan los datos, por ello requieren de un mecanismo para detectar y corregir errores.
					</p>
				</section>
				<section>
					<b>Tipos de errores</b>
					<br>
					<p>Cada vez que los bits de información se transfieren de un punto a otro, pueden sufrir interferencias. Esto provoca que puedan cambiar la forma de la señal que se vaya a recibir.
						<br>
						Un solo error de un bit puede cambiar un 0 a un 1 o viceversa, incluso llegando a cambiar varios bits.
					</p>
				</section>
				<section>
					<ul>
						<li><b>Error de un solo bit:</b> Como su propio nombre lo dice, este se trata cuando un solo bit de una cantidad de datos dada se cambia de un 0 a un 1 o de un 1 a un 0.</li>
						<li><b>Error en ráfaga:</b> Sucede cuando dos o más bits en la unidad de datos cambian de 0 a 1 o viceversa, esto es peor en estos casos ya que la duración del ruido será más largo
						ya que el error afecta a más bits.</li>
					</ul>
				</section>
				<section>
					<b>Redundancia</b>
					<br>
					<p>El concepto central de detectara o corregir errores es la redundancia. Para ser capaces de detectar o corregir errores, se necesitan mandar bits extra junto a nuestros datos. Esta redundancia en los bits
						que nosotros añadimos son eliminados por el receptor, su presencia permite al receptor detectar o corregir los bits corruptos.			
					</p>
				</section>
				<section>
					<b>¿Corregir o Detectar?</b>
					<br>
					<p>La corrección de errores es más díficil que la detección</p> <br>
					<table>
						<tr>
							<th>Concepto</th>
							<th>Descripción</th>
						</tr>
						<tr>
							<td>Detección de errores</td>
							<td>Se busca solo observar si ha ocurrido un error, no nos interesa el número de errores o si fue un solo bit o varios</td>
						</tr>
						<tr>
							<td>Corrección de errores</td>
							<td>Se necesita saber el número exacto de bits corruptos y su localización en el mensaje, siendo entre más bits, más posibles errores de localización.</td>
						</tr>
					</table>
				</section>
				<section>
					<b>Forward error correction o Retransmisión</b>
					<br>
					<p>
						Existen 2 métodos de corrección de errores:
					</p>
					<br>
					<ul>
						<li><b>Forward error correction: </b>Es el proceso donde el receptor intenta adivinar el mensaje usando los bits restantes.</li>
						<li><b>Retransmisión: </b>Es una técnica en la que el receptor detecta la ocurrencia de algún error y le pide al emisor reenviar el mensaje. Esto se hace hasta que el mensaje llegue
						sin ningún tipo de error (no todos los errores pueden ser detectados)</li>
					</ul>
				</section>
				<section>
					<b>Codificar</b> <br>
					<p>La redundancia a adquirido varios esquemas de código. El emisor añade redundancia a los bits mientras un proceso crea una relación entre los bits redundantes y los bits verdaderos de los detectado 
						El receptor verifica los dos sets de bits para poder detectar o corregir los errores.
					</p>
				</section>
				<section>
					<b>Codificación por bloques</b> <br>
					<p>En la codificación por bloques dividimos nuestro mensaje por bloques, cada uno con "K" cantidad de bits llamada "Palabra". Se añaden "r" cantidad de bits redundantes a cada bloque para 
						crear la longitud <br> <b>"n= k + r"</b>. El resultado será n-bits por bloque llamados "Código". 
					</p>
				</section>
				<section>
					<b>Detección de errores</b>
					<br>
					<p>Existen maneras de detectar errores usando la codificación por bloques.</p>
					<ol>
						<li>El receptor pudo (o puede) encontrar la lista de los "Códigos" válidos</li>
						<li>El "Código" original ha sido cambiado a uno invalido</li>
					</ol>
				</section>
				<section>
					<p>El emisor crea los "Códigos" fuera de las "Palabras" usando un generador que replica las reglas y procedimientos de la codificación. Cada "código" es enviado al receptor puede ser cambiada
						durante la transmisión. Si el receptor detecta que el "código" es el mismo que uno de los "Códigos" validos, la "Palabra" es aceptada, de no ser así de descarta, si este llega a ser corrupta
					durante la transmisión, pero el el "código" aun así es igual los errores restantes serán indetectables. </p>
				</section>
				<section>
					<b>Corrección de errores</b> <br>
					<p>En una correción de errores, el receptor necesita saber que un solo "código" es invalido. Por ello el receptor necesita encontrar (o adivinar) el "código" original mandado.</p>
				</section>
				<section>
					<b>Hamming Distance</b> <br>
					<p>Uno de los concpetos centrales en la codificación para los controles de errores es la idea del "Hamming Distance". La Hamming distance entre 2 "Palabras" (del mismo tamaño) es el número de 
						diferencias entre sus bits correspondientes. Esto puede ser fácilmente encontrado usando un operador de XOR en las 2 "Palabras" y contando el numero de 1s en el resultado.
					</p>
				</section>
				<section>
					<b>Código de bloques lineales</b> <br>
					<p>Casi todos los bloques de códigos usan un subconjunto llamado Código de bloques lineales. Los bloques normalmente son no lineales, esto hace que el ánalisis de su estructura y la detección
						y correción de errores sea más difícil. En el uso del XOR de cualquiera de los 2 "códigos" validos crea otro "código" válido.
					</p>
				</section>
				<section>
					<b>Códigos cíclicos</b> <br>
					<p>
						Los códigos cíclicos es un tipo de Código de bloques de código con una propiedad extra. En el código cíclico si un "Código" es rotado o sus digitos se ponen al revés, el resultado será otro "Código" diferente.
					</p>
				</section>
				<section>
					<b>Implementación en el Hardware</b> <br>
					<p>Una ventaja de los códigos cíclicos es que el decodificador y el códificador pueden ser fácilmente implementados en hardware usados por bastantes dispositivos eléctronicos.
						Pero la implementación de este incrementa el ratio de verificador de bits.
					</p>
				</section>
				<section>
				<b>Ventajas de los códigos cíclicos</b> <br>
				<p>Los códigos cíclicos son buenos para: </p>
				<ul>
					<li>Detectar errores de 1 bit, errores dobles, errores de números impares y errores de ráfaga.</li>
					<li>Estos pueden ser fácilmente implementados dentro de un hardware
						y software, siendo más útil en el hardware.</li>
				</ul> 
				</section>
				<section>
					<b>Checksum</b> <br>
					<p>
						El último tipo de detector de errores es el CHECKSUM. Este es usado en el internet de diversos protocolos a pesar de que estos no se encuentran en la capa de enlace de datos.
						De igual manera que los códigos lineales y cíclicos, el Checksum se basa en la redundancia. Hoy en día muchos protocolos utilizan este método para la detección de errores.
					</p>
				</section>
				<section>
					<b>Uso</b> <br>
					<p>
						La aplicación del Checksum se basa en mandar los bits al receptor mas la suma de los bits dentro del paquete, por lo que el receptor tendra 1 bit mas y este mismo podrá comparar el resultado
						del checksum con los demás bits. <br>
					</p>
				</section>
				<section>
					<b>Checksum en el internet</b>
					<br>
					<p>El internet tradicional utiliza un checksum de 16 bits, el receptor calcula el resultado de la siguiente forma:</p>
					<ol>
						<li>El mensaje es dividido en las palabras de 16 bits</li>
						<li>El valor de la palabra del checksum esta establecida a 0</li>
						<li>Todas las palabras incluidas en el checksum son añadidas usando una adición del complemento a uno</li>
						<li>La suma esta complementada y se vuelve el Checksum</li>
						<li>El Checksum es mandado con la data</li>
					</ol>
				</section>
				<section>
					<p>El receptor puede usar los siguientes pasos para detectar errores</p>
					<ol>
						<li>El mensaje (incluido el checksum) se divide entre las palabras de 16 bits</li>
						<li>Todas las palabras son añadidas sumandole 1 más</li>
						<li>La suma es complementada y se vuelve el nuevo checksum</li>
						<li>Si el valor del checksum es 0, el mensaje es aceptado; de otra manera, será rechazado</li>
					</ol>
				</section>
